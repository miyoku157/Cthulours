//------------------------------------------------------------------------------
// <auto-generated>
//     Ce code a été généré par un outil.
//     Version du runtime :4.0.30319.34014
//
//     Les modifications apportées à ce fichier peuvent provoquer un comportement incorrect et seront perdues si
//     le code est régénéré.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections.Generic;
using AiRuleEngine;
using System.Collections;
using AssemblyCSharp;

namespace AssemblyCSharp
{
    public static class Niveau
    {
        public static int turnCount = 0;
        public static GameObject[,] grille { get; set; }

        public static Attaque[] list_attaque { get; set; }

        public static List<GameObject>[] list_element = new List<GameObject>[3];

        public class coordonne
        {
            public int index_x;
            public int index_y;
            public coordonne()
            {
                index_x = -1;
                index_y = -1;
            }
            public coordonne(int _x, int _y)
            {
                index_x = _x;
                index_y = _y;
            }
            public override bool Equals(object obj)
            {
                coordonne coord = (coordonne)obj;
                if (this.index_x == coord.index_x && this.index_y == coord.index_y)
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
        };

        public static Pouvoir[] list_pouvoir { get; set; }
        public static Special[] list_capacite { get; set; }


        public static void setVariable(GameObject objet, string scriptName)
        {
            if (scriptName.Equals("EnemyDetector"))
            {
                InferenceEngine infe = objet.GetComponent<InferenceEngine>();
                Variable var = new Variable("nb_enn", objet.GetComponent<EnemyDetector>().compteurDetection);
                infe.GetState().SetVariable(var);
            }
        }


        private static void test_4_Case(ref int i, ref int j, ref int distance, ref int[,] tableau_distance, ref coordonne[] cas_use, ref int x_arrive, ref int y_arrive, ref List<coordonne> used)
        {
            distance--;
            int compteur_tab = 0;
            coordonne cas_haut = new coordonne();
            cas_haut.index_x = i;
            cas_haut.index_y = j + 1;
            coordonne cas_bas = new coordonne();
            cas_bas.index_x = i;
            cas_bas.index_y = j - 1;
            coordonne cas_droite = new coordonne();
            cas_droite.index_x = i + 1;
            cas_droite.index_y = j;
            coordonne cas_gauche = new coordonne();
            cas_gauche.index_x = i - 1;
            cas_gauche.index_y = j;
            if (cas_haut.index_y < 30)
            {
                if (distance == tableau_distance[cas_haut.index_x, cas_haut.index_y])
                {

                    cas_use[compteur_tab] = cas_haut;
                    compteur_tab++;
                }
            }
            if (cas_bas.index_y >= 0)
            {
                if (distance == tableau_distance[cas_bas.index_x, cas_bas.index_y])
                {

                    cas_use[compteur_tab] = cas_bas;
                    compteur_tab++;
                }
            }
            if (cas_droite.index_x < 53)
            {
                if (distance == tableau_distance[cas_droite.index_x, cas_droite.index_y])
                {

                    cas_use[compteur_tab] = cas_droite;
                    compteur_tab++;
                }
            }
            if (cas_gauche.index_x >= 0)
            {
                if (distance == tableau_distance[cas_gauche.index_x, cas_gauche.index_y])
                {

                    cas_use[compteur_tab] = cas_gauche;
                    compteur_tab++;
                }
            }
        }

        public static List<char> boucle_path(int x, int y, int x_arrive, int y_arrive)
        {
            List<coordonne> used = new List<coordonne>();
            bool roll = true;
            int x_depart = x;
            int y_depart = y;
            int compteur = 0;
            int delta_x = 0;
            int delta_y = 0;
            int distance = 0;
            List<char> deplacement = new List<char>();
            int[,] tableau_distance = new int[Chargement_jeu.bornes[0], Chargement_jeu.bornes[1]];
            for (int i = 0; i < Chargement_jeu.bornes[0]; i++)
            {
                for (int j = 0; j < Chargement_jeu.bornes[1]; j++)
                {
                    delta_x = x_arrive - (int)Niveau.grille[i, j].gameObject.transform.position.x;
                    delta_y = y_arrive - (int)Niveau.grille[i, j].gameObject.transform.position.y;
                    tableau_distance[i, j] = Math.Abs(delta_x) + Math.Abs(delta_y);
                }
            }

            delta_x = x;
            delta_y = y;
            delta_x -= x_arrive;
            delta_y -= y_arrive;
            distance = Math.Abs(delta_x) + Math.Abs(delta_y);
            tableau_distance[x, y] = 100;
            for (int i = 0; i < Chargement_jeu.bornes[0]; i++)
            {
                for (int j = 0; j < Chargement_jeu.bornes[1]; j++)
                {
                    Niveau.grille[i, j].GetComponent<Case>().GetComponent<SpriteRenderer>().color = Color.white;

                }
            }
            used.Add(new coordonne(x, y));
            while (distance >= 0 && compteur < 1000)
            {


                coordonne[] cas_use = new coordonne[3];
                cas_use[0] = new coordonne();
                cas_use[1] = new coordonne();
                cas_use[2] = new coordonne();
                test_4_Case(ref x, ref y, ref distance, ref tableau_distance, ref cas_use, ref x_arrive, ref y_arrive, ref used);


                int randcompt = 0;
                delta_x = 0;
                delta_y = 0;
                bool isRandom = false;
                if ((cas_use[0].index_x != -1 && cas_use[0].index_y != -1))
                {
                    if (cas_use[0].index_x >= 0 && cas_use[0].index_x < 53 && cas_use[0].index_y >= 0 && cas_use[0].index_y < 30
                        && cas_use[1].index_x >= 0 && cas_use[1].index_x < 53 && cas_use[1].index_y >= 0 && cas_use[1].index_y < 30
                        && cas_use[2].index_x >= 0 && cas_use[2].index_x < 53 && cas_use[2].index_y >= 0 && cas_use[2].index_y < 30)
                    {
                        if (!Niveau.grille[cas_use[0].index_x, cas_use[0].index_y].GetComponent<Case>().occupe
                            && !Niveau.grille[cas_use[1].index_x, cas_use[1].index_y].GetComponent<Case>().occupe
                            && !Niveau.grille[cas_use[2].index_x, cas_use[2].index_y].GetComponent<Case>().occupe)
                        {
                            randcompt = 3;
                            int random = UnityEngine.Random.Range(0, randcompt - 1);
                            delta_x = x - cas_use[random].index_x;
                            delta_y = y - cas_use[random].index_y;
                            isRandom = true;
                        }
                    }
                    if (cas_use[0].index_x >= 0 && cas_use[0].index_x < 53 && cas_use[0].index_y >= 0 && cas_use[0].index_y < 30
                       && cas_use[1].index_x >= 0 && cas_use[1].index_x < 53 && cas_use[1].index_y >= 0 && cas_use[1].index_y < 30)
                    {
                        if (!Niveau.grille[cas_use[0].index_x, cas_use[0].index_y].GetComponent<Case>().occupe
                           && !Niveau.grille[cas_use[1].index_x, cas_use[1].index_y].GetComponent<Case>().occupe)
                        {
                            randcompt = 2;
                            int random = UnityEngine.Random.Range(0, randcompt - 1);
                            delta_x = x - cas_use[random].index_x;
                            delta_y = y - cas_use[random].index_y;
                            isRandom = true;
                        }
                    }
                    if (cas_use[0].index_x >= 0 && cas_use[0].index_x < 53 && cas_use[0].index_y >= 0 && cas_use[0].index_y < 30 && isRandom == false)
                    {
                        if (!Niveau.grille[cas_use[0].index_x, cas_use[0].index_y].GetComponent<Case>().occupe)
                        {
                            delta_x = x - cas_use[0].index_x;
                            delta_y = y - cas_use[0].index_y;
                            randcompt++;
                        }
                    }
                    if (cas_use[1].index_x >= 0 && cas_use[1].index_x < 53 && cas_use[1].index_y >= 0 && cas_use[1].index_y < 30 && isRandom == false)
                    {
                        if (!Niveau.grille[cas_use[1].index_x, cas_use[1].index_y].GetComponent<Case>().occupe)
                        {
                            delta_x = x - cas_use[1].index_x;
                            delta_y = y - cas_use[1].index_y;
                            randcompt++;
                        }
                    }
                }
                if (randcompt > 0)
                {

                    if (delta_x < 0)
                    {
                        x += 1;
                        cas_use[0].index_x += 1;
                        cas_use[1].index_x += 1;
                        deplacement.Add('D');
                    }
                    else if (delta_x > 0)
                    {
                        cas_use[0].index_x -= 1;
                        cas_use[1].index_x -= 1;
                        x -= 1;
                        deplacement.Add('G');
                    }
                    if (delta_y > 0)
                    {
                        y -= 1;
                        cas_use[0].index_y -= 1;
                        cas_use[1].index_y -= 1;
                        deplacement.Add('B');
                    }
                    else if (delta_y < 0)
                    {
                        y += 1;
                        cas_use[0].index_y += 1;
                        cas_use[1].index_y += 1;
                        deplacement.Add('H');
                    }
                    //Niveau.grille [x, y].GetComponent<SpriteRenderer> ().color = Color.blue;
                    used.Add(new coordonne(x, y));
                    tableau_distance[x, y] = 100;
                    roll = true;
                }
                else
                {
                    if (distance > 0)
                    {
                        if (roll)
                        {
                            distance += 3;



                            roll = false;
                        }
                        else
                        {
                            for (int f = 0; f < used.Count; f++)
                            {
                                delta_x = x_arrive - used[f].index_x;
                                delta_y = y_arrive - used[f].index_y;
                                tableau_distance[used[f].index_x, used[f].index_y] = Math.Abs(delta_x) + Math.Abs(delta_y);
                            }

                            roll = rollBack(ref tableau_distance, ref cas_use, ref x, ref y, ref deplacement, ref distance, ref x_arrive, ref y_arrive, ref x_depart, ref y_depart);

                        }
                    }

                }
                compteur++;


            }
            return deplacement;
        }
        private static bool rollBack(ref int[,] tab_distance, ref coordonne[] cas_use, ref int x, ref int y, ref List<char> deplacement, ref int distance, ref int x_arrive, ref int y_arrive, ref int x_depart, ref int y_depart)
        {

            if (deplacement.Count > 0)
            {

                char direction = deplacement[deplacement.Count - 1];
                deplacement.RemoveAt(deplacement.Count - 1);
                switch (direction)
                {
                    case 'D':
                        cas_use[0].index_x -= 1;
                        cas_use[1].index_x -= 1;
                        x -= 1;
                        break;
                    case 'G':
                        cas_use[0].index_x += 1;
                        cas_use[1].index_x += 1;
                        x += 1;
                        break;
                    case 'B':
                        cas_use[0].index_y += 1;
                        cas_use[1].index_y += 1;
                        y += 1;
                        break;
                    case 'H':
                        cas_use[0].index_y -= 1;
                        cas_use[1].index_y -= 1;
                        y -= 1;
                        break;
                }



            }
            distance += 2;


            return true;
        }
    }
}
