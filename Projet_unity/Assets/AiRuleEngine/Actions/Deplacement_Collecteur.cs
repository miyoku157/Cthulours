//------------------------------------------------------------------------------
// <auto-generated>
//     Ce code a été généré par un outil.
//     Version du runtime :4.0.30319.34014
//
//     Les modifications apportées à ce fichier peuvent provoquer un comportement incorrect et seront perdues si
//     le code est régénéré.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using System;
using System.Collections.Generic;
using AssemblyCSharp;
using System.Collections;


namespace AiRuleEngine
{
#if UNITY_EDITOR
	[ScriptName("Deplacement_Collecteur")]
	[ScriptCategory("Movement")]
#endif
    public class Deplacement_Collecteur : BaseAction
    {

        private GameObject Go;
        private int direction;
        private bool calcule = false;
		private List<char> deplacement;
		private Unite ele;
		private int mouvement;
		private int init= 0;
        void Start()
        {
            Go = this.gameObject;
			init = 0;
        }

        public override bool Execute()
        {
            ele = Go.GetComponent<Unite>();
            deplacement = ele.deplacement;
            mouvement = ele.mouvement;
            State etat = Go.GetComponent<State>();
            Variable var = new Variable();
            etat.GetVariable("prox", out var);
            if ((int)var.GetValue() == 1)
            {
                if (!calcule)
                {
                    direction = 1;
                    Vector2 res = FindRessource();
                    ele.deplacement = Niveau.boucle_path((int)this.gameObject.transform.position.x, (int)this.gameObject.transform.position.y, (int)res.x, (int)res.y);
                    deplacement = ele.deplacement;
                    calcule = true;
					init=1;
                }
            }
            else if ((int)var.GetValue() == 2)
            {
                if (!calcule)
                {
                    direction = 2;
                    Vector2 res = FindRessource();
                    ele.deplacement = Niveau.boucle_path((int)this.gameObject.transform.position.x, (int)this.gameObject.transform.position.y, (int)res.x, (int)res.y);
                    calcule = true;
                    if (Go.GetComponent<Element>().camp == "Ours")
                    {
                        Score.ressource_IA[0] += Unite.stockage*init;
						Score.ressourcediv_IA[0][0] += Unite.stockage*init * Batiment.aggressivite / 100;
						Score.ressourcediv_IA[0][1] += Unite.stockage*init * (1 - Batiment.aggressivite / 100) * Batiment.defense / 100;
						Score.ressourcediv_IA[0][2] += Unite.stockage*init * (1 - Batiment.aggressivite / 100) * Batiment.technologie / 100;

                    }
                    else if (Go.GetComponent<Element>().camp == "Poulpe")
                    {
						Score.ressource_IA[1] += Unite.stockage*init;
						Score.ressourcediv_IA[1][0] += Unite.stockage *init* Batiment.aggressivite / 100;
						Score.ressourcediv_IA[1][1] += Unite.stockage*init * (1 - Batiment.aggressivite / 100) * Batiment.defense / 100;
						Score.ressourcediv_IA[1][2] += Unite.stockage *init* (1 - Batiment.aggressivite / 100) * Batiment.technologie / 100;
                    }
                }
            }
            else if ((int)var.GetValue() == 0)
            {
                calcule = false;
            }
            if (deplacement != null)
            {

                if (deplacement.Count != 0)
                {
					for (int i = 0; i < ele.hauteur; i++)
					{
						for (int j = 0; j < ele.largeur; j++)
						{
							ele.list_case[i, j] = Niveau.grille[(int)(i + Go.transform.position.x - 0.5), (int)(j + Go.transform.position.y - 0.5)];
							ele.list_case[i, j].GetComponent<Case>().occupe = false;
							ele.list_case[i, j].GetComponent<Case>().element = null;
						}
					}

					StartCoroutine("MoveTowards");
                }
                else
                {
                    Vector2 res = FindRessource();
                    ele.deplacement = Niveau.boucle_path((int)this.gameObject.transform.position.x, (int)this.gameObject.transform.position.y, (int)res.x, (int)res.y);
                    mouvement = 0;
                }
            }
            return true;
        }

		private IEnumerator MoveTowards()
		{
			float tParam = 0;
			Vector3 pos = Go.transform.position;
			char direction = deplacement[0];
			Vector2 res = FindRessource();

			if(deplacement.Count != 0)
			{
				switch (direction)
				{
					case 'D':
						if (!Niveau.grille[(int)(Go.transform.position.x + 0.5), (int)(Go.transform.position.y - 0.5)].GetComponent<Case>().occupe)
						{
							for (int i = 0; i < ele.hauteur; i++)
							{
								for (int j = 0; j < ele.largeur; j++)
								{
									ele.list_case[i, j] = Niveau.grille[(int)(i + Go.transform.position.x + 0.5), (int)(j + Go.transform.position.y - 0.5)];
									ele.list_case[i, j].GetComponent<Case>().occupe = true;
									ele.list_case[i, j].GetComponent<Case>().element = Go.gameObject;
								}
							}

							Go.transform.rotation = Quaternion.Euler(new Vector3(0, 0, 270));

							while(Go.transform.position.x < pos.x + 1.0f)
							{
								tParam += Time.deltaTime;
								Go.transform.position = new Vector3(Mathf.Lerp(pos.x, pos.x + 1f, tParam), pos.y, pos.z);
								yield return new WaitForSeconds(0.01f);
							}
							deplacement.RemoveAt(0);
						}
						else
						{
							if (ele.camp.Equals("Ours"))
							{
								ele.deplacement = Niveau.boucle_path((int)this.gameObject.transform.position.x, (int)this.gameObject.transform.position.y, (int)res.x, (int)res.y);
							}
							else
							{
								ele.deplacement = Niveau.boucle_path((int)this.gameObject.transform.position.x, (int)this.gameObject.transform.position.y, (int)res.x, (int)res.y);
							}
						}
						break;
					case 'G':
						if (!Niveau.grille[(int)(Go.transform.position.x - 1.5), (int)(Go.transform.position.y - 0.5)].GetComponent<Case>().occupe)
						{
							for (int i = 0; i < ele.hauteur; i++)
							{
								for (int j = 0; j < ele.largeur; j++)
								{
									ele.list_case[i, j] = Niveau.grille[(int)(i + Go.transform.position.x - 1.5), (int)(j + Go.transform.position.y - 0.5)];
									ele.list_case[i, j].GetComponent<Case>().occupe = true;
									ele.list_case[i, j].GetComponent<Case>().element = Go.gameObject;
								}
							}

							Go.transform.rotation = Quaternion.Euler(new Vector3(0, 0, 90));
							
							while(Go.transform.position.x > pos.x - 1.0f)
							{
								tParam += Time.deltaTime;
								Go.transform.position = new Vector3(Mathf.Lerp(pos.x, pos.x - 1f, tParam), pos.y, pos.z);
								yield return new WaitForSeconds(0.01f);
							}
							
							deplacement.RemoveAt(0);
						}
						else
						{
							if (ele.camp.Equals("Ours"))
							{
								ele.deplacement = Niveau.boucle_path((int)this.gameObject.transform.position.x, (int)this.gameObject.transform.position.y, (int)res.x, (int)res.y);
							}
							else
							{
								ele.deplacement = Niveau.boucle_path((int)this.gameObject.transform.position.x, (int)this.gameObject.transform.position.y, (int)res.x, (int)res.y);
							}
						}
						break;
					case 'H':
						if (!Niveau.grille[(int)(Go.transform.position.x - 0.5), (int)(Go.transform.position.y + 0.5)].GetComponent<Case>().occupe)
						{
							for (int i = 0; i < ele.hauteur; i++)
							{
								for (int j = 0; j < ele.largeur; j++)
								{
									ele.list_case[i, j] = Niveau.grille[(int)(i + Go.transform.position.x - 0.5), (int)(j + Go.transform.position.y + 0.5)];
									ele.list_case[i, j].GetComponent<Case>().occupe = true;
									ele.list_case[i, j].GetComponent<Case>().element = Go.gameObject;
								}
							}

							Go.transform.rotation = Quaternion.Euler(new Vector3(0, 0, 0));
							
							while(Go.transform.position.y < pos.y + 1.0f)
							{
								tParam += Time.deltaTime;
								Go.transform.position = new Vector3(pos.x, Mathf.Lerp(pos.y, pos.y + 1f, tParam), pos.z);
								yield return new WaitForSeconds(0.01f);
							}
							
							deplacement.RemoveAt(0);
						}
						else
						{
							if (ele.camp.Equals("Ours"))
							{
								ele.deplacement = Niveau.boucle_path((int)this.gameObject.transform.position.x, (int)this.gameObject.transform.position.y, (int)res.x, (int)res.y);
							}
							else
							{
								ele.deplacement = Niveau.boucle_path((int)this.gameObject.transform.position.x, (int)this.gameObject.transform.position.y, (int)res.x, (int)res.y);
							}
						}
						break;
					case 'B':
						if (!Niveau.grille[(int)(Go.transform.position.x - 0.5), (int)(Go.transform.position.y - 1.5)].GetComponent<Case>().occupe)
						{
							for (int i = 0; i < ele.hauteur; i++)
							{
								for (int j = 0; j < ele.largeur; j++)
								{
									ele.list_case[i, j] = Niveau.grille[(int)(i + Go.transform.position.x - 0.5), (int)(j + Go.transform.position.y - 1.5)];
									ele.list_case[i, j].GetComponent<Case>().occupe = true;
									ele.list_case[i, j].GetComponent<Case>().element = Go.gameObject;
								}
							}

							Go.transform.rotation = Quaternion.Euler(new Vector3(0, 0, 180));
							
							while(Go.transform.position.y > pos.y - 1.0f)
							{
								tParam += Time.deltaTime;
								Go.transform.position = new Vector3(pos.x, Mathf.Lerp(pos.y, pos.y - 1f, tParam), pos.z);
								yield return new WaitForSeconds(0.01f);
							}
							
							deplacement.RemoveAt(0);
						}
						else
						{
							if (ele.camp.Equals("Ours"))
							{
								ele.deplacement = Niveau.boucle_path((int)this.gameObject.transform.position.x, (int)this.gameObject.transform.position.y, (int)res.x, (int)res.y);
							}
							else
							{
								ele.deplacement = Niveau.boucle_path((int)this.gameObject.transform.position.x, (int)this.gameObject.transform.position.y, (int)res.x, (int)res.y);
							}
						}
						break;
				}
			}
			else
			{
				for (int i = 0; i < ele.hauteur; i++)
				{
					for (int j = 0; j < ele.largeur; j++)
					{
						ele.list_case[i, j] = Niveau.grille[(int)(i + Go.transform.position.x - 0.5), (int)(j + Go.transform.position.y - 0.5)];
						ele.list_case[i, j].GetComponent<Case>().occupe = true;
						ele.list_case[i, j].GetComponent<Case>().element = this.gameObject;
					}
				}
			}

			mouvement--;
			
			if(mouvement > 0 && deplacement[0] != null)
				StartCoroutine("MoveTowards");
			
			yield break;
		}

        private Vector2 FindRessource()
        {
            string search = null;
			string tag = null;
			if (Go.GetComponent<Element> ().camp == "Ours") {
				tag="_Ours";
			} else {
				tag="_Poulpe";	
			}
            if (direction == 1)
            {
                search = "QG"+tag;
            }
            else if (direction == 2)
            {
                search = "ressources"+tag;
            }
            GameObject[] ressources = GameObject.FindGameObjectsWithTag(search);
            double distance = 1000;
			GameObject resultat=null;
            foreach (GameObject res in ressources)
            {

                if (distance > Vector3.Distance(Go.transform.position, res.transform.position))
                {
                    distance = Vector3.Distance(Go.transform.position, res.transform.position);
                    resultat = res;
                }
            }
			if (search == "QG"+tag) {
				foreach(GameObject game in resultat.GetComponent<Batiment>().list_case	){
					if (distance > Vector3.Distance(Go.transform.position, game.transform.position))
					{
						distance = Vector3.Distance(Go.transform.position, game.transform.position);
						resultat = game;
					}
				}
			}
			return resultat.transform.position;

        }
    }
}

