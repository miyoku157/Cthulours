//------------------------------------------------------------------------------
// <auto-generated>
//     Ce code a été généré par un outil.
//     Version du runtime :4.0.30319.34014
//
//     Les modifications apportées à ce fichier peuvent provoquer un comportement incorrect et seront perdues si
//     le code est régénéré.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
using AiRuleEngine;

namespace AssemblyCSharp
{
    public class Batiment : Element
    {
        private int num;
        private InferenceEngine engine;
        private GameObject unite;
        private Unite SCUnite;
        private Transform tranform;
        public static double technologie;
        public static double defense;
        public static double aggressivite;
        protected Attaque attaque { get; set; }
        private Production typeA = null;
		public bool is_product=false;
		public bool rech_product = false;
        // Use this for initialization
        protected override void Start()
        {
            num = 1;
        }

        // Update is called once per frame
        protected override void Update()
        {
            base.Update();
            aJoue = true;
        }

        public void setProd(Production _ty)
        {
            typeA = _ty;
        }

        void execute_product()
        {
            Produire(typeA.nom, Production.is_done);
			if (typeA.type == "production") {
				is_product = false;
			} else {
				rech_product=false;						
			}

        }
        public void Produire(string nomUnite, bool[][] recherche)
        {
            Vector2 depart = new Vector2(transform.position.x - largeur / 2 - 0.5f,
                                         transform.position.y - hauteur / 2 - 1.5f);

            if (Niveau.grille[(int)depart.x, (int)depart.y].GetComponent<Case>().occupe == false)
            {
                //SCUnite = new Unite();
                //0=ours, 1=poulpe; 0=bon arme; 1 bon armure, 2 bon pv
                double[][] bonus = new double[2][];
                for (int i = 0; i < 2; i++)
                {
                    bonus[i] = new double[3];
                    for (int j = 0; j < 3; j++)
                    {
                        bonus[i][j] = 1;
                    }
                }
                if (recherche[0][0])
                {
                    bonus[0][0] = 1.3;
                }
                if (recherche[0][1])
                {
                    bonus[0][1] = 1.2;
                }
                if (recherche[1][0])
                {
                    bonus[1][0] = 1.3;
                }
                if (recherche[1][1])
                {
                    bonus[1][1] = 1.2;
                }

                switch (nomUnite)
                {
                    case "Collecteur_ours":
                        unite = Instantiate(Resources.Load("Prefab/Ours/Collecteur")) as GameObject;
                        SCUnite = unite.AddComponent<Unite>();
                        SCUnite.Initialize("Collecteur_ours#" + num, "Ours", "", 1, 5 * bonus[0][1], 1, 1, 1, 5, false, 5);
                        SCUnite.mouvement = 1;
                        num++;
                        unite.AddComponent<RuleBase>();
                        unite.AddComponent<State>();
                        unite.transform.position = PlacerUnite(unite);
                        engine = unite.AddComponent<InferenceEngine>();
                        engine.m_RuleBaseFilePath = "Collecteur";
                        engine.m_RuleBaseTick = (int)(Chargement_jeu.turnTimeStatic * 2000f);
                        break;
						case "Collecteur_Poulpe":
							unite = Instantiate(Resources.Load("Prefab/Poulpe/Collecteur")) as GameObject;
							SCUnite = unite.AddComponent<Unite>();
							SCUnite.Initialize("Collecteur_Poulpe#" + num, "Poulpe", "", 1, 5 * bonus[0][1], 1, 1, 1, 5, false, 5);
							SCUnite.mouvement = 1;
							num++;
							unite.AddComponent<RuleBase>();
							unite.AddComponent<State>();
							unite.transform.position = PlacerUnite(unite);
							engine = unite.AddComponent<InferenceEngine>();
							engine.m_RuleBaseFilePath = "Collecteur";
							engine.m_RuleBaseTick = (int)(Chargement_jeu.turnTimeStatic * 2000f);
							break;
                    case "Ourson":
                        unite = Instantiate(Resources.Load("Prefab/Ours/Ourson")) as GameObject;
                        SCUnite = unite.AddComponent<Unite>();
                        SCUnite.Initialize("Ourson #" + num, "Ours", "", 1, 10 * bonus[0][1], 0, 1, 0, 10, false, 50);
                        SCUnite.attaque = new Attaque(1 * bonus[0][0], 0, 5, 0, "normal", 2);
                        SCUnite.mouvement = 2;
                        num++;
                        unite.AddComponent<RuleBase>();
                        unite.AddComponent<State>();
                        unite.transform.position = PlacerUnite(unite);
                        engine = unite.AddComponent<InferenceEngine>();
                        engine.m_RuleBaseFilePath = "unite";
                        engine.m_RuleBaseTick = (int)(Chargement_jeu.turnTimeStatic * 2000f);

                        break;
					case "Ours Blanc":
						unite = Instantiate(Resources.Load("Prefab/Ours/Ours Blanc")) as GameObject;
						SCUnite = unite.AddComponent<Unite>();
						SCUnite.Initialize("Ours Blanc #" + num, "Ours", "", 1, 10 * bonus[0][1], 0, 1, 0, 10, false, 150);
						SCUnite.attaque = new Attaque(1 * bonus[0][0], 0, 5, 0, "normal", 2);
						SCUnite.mouvement = 1;
						num++;
						unite.AddComponent<RuleBase>();
						unite.AddComponent<State>();
						unite.transform.position = PlacerUnite(unite);
						engine = unite.AddComponent<InferenceEngine>();
						engine.m_RuleBaseFilePath = "unite";
						engine.m_RuleBaseTick = (int)(Chargement_jeu.turnTimeStatic * 2000f);
						
						break;
					case "Ours de guerre":
						unite = Instantiate(Resources.Load("Prefab/Ours/Ours de guerre")) as GameObject;
						SCUnite = unite.AddComponent<Unite>();
						SCUnite.Initialize("Ours de guerre #" + num, "Ours", "", 1, 10 * bonus[0][1], 0, 1, 0, 10, false, 300);
						SCUnite.attaque = new Attaque(1 * bonus[0][0], 0, 5, 0, "normal", 2);
						SCUnite.mouvement = 1;
						num++;
						unite.AddComponent<RuleBase>();
						unite.AddComponent<State>();
						unite.transform.position = PlacerUnite(unite);
						engine = unite.AddComponent<InferenceEngine>();
						engine.m_RuleBaseFilePath = "unite";
						engine.m_RuleBaseTick = (int)(Chargement_jeu.turnTimeStatic * 2000f);
						
						break;
                    case "Poulpy":
                        unite = Instantiate(Resources.Load("Prefab/Poulpe/Poulpy")) as GameObject;
                        SCUnite = unite.AddComponent<Unite>();
                        SCUnite.Initialize("Poulpy #" + num, "Poulpe", "", 1, 8 * bonus[1][1], 10, 1, 0, 10, false, 50);
                        SCUnite.attaque = new Attaque(1 * bonus[1][0], 0, 5, 0, "normal", 2);
                        SCUnite.mouvement = 2;
                        num++;
                        unite.AddComponent<RuleBase>();
                        unite.AddComponent<State>();
                        unite.transform.position = PlacerUnite(unite);
                        engine = unite.AddComponent<InferenceEngine>();
                        engine.m_RuleBaseFilePath = "unite";
                        engine.m_RuleBaseTick = (int)(Chargement_jeu.turnTimeStatic * 2000f);

                        break;
					case "Octopus":
						unite = Instantiate(Resources.Load("Prefab/Poulpe/Octopus")) as GameObject;
						SCUnite = unite.AddComponent<Unite>();
						SCUnite.Initialize("Octopus #" + num, "Poulpe", "", 1, 8 * bonus[1][1], 10, 1, 0, 10, false, 150);
						SCUnite.attaque = new Attaque(1 * bonus[1][0], 0, 5, 0, "normal", 2);
						SCUnite.mouvement = 2;
						num++;
						unite.AddComponent<RuleBase>();
						unite.AddComponent<State>();
						unite.transform.position = PlacerUnite(unite);
						engine = unite.AddComponent<InferenceEngine>();
						engine.m_RuleBaseFilePath = "unite";
						engine.m_RuleBaseTick = (int)(Chargement_jeu.turnTimeStatic * 2000f);
						
						break;
					case "Cyber-poulpe":
						unite = Instantiate(Resources.Load("Prefab/Poulpe/Cyber-poulpe")) as GameObject;
						SCUnite = unite.AddComponent<Unite>();
						SCUnite.Initialize("Cyber-poulpe #" + num, "Poulpe", "", 1, 8 * bonus[1][1], 10, 1, 0, 10, false, 300);
						SCUnite.attaque = new Attaque(1 * bonus[1][0], 0, 5, 0, "normal", 2);
						SCUnite.mouvement = 1;
						num++;
						unite.AddComponent<RuleBase>();
						unite.AddComponent<State>();
						unite.transform.position = PlacerUnite(unite);
						engine = unite.AddComponent<InferenceEngine>();
						engine.m_RuleBaseFilePath = "unite";
						engine.m_RuleBaseTick = (int)(Chargement_jeu.turnTimeStatic * 2000f);
						
						break;
                    default:
                        Debug.Log("Nom d'unité inconnu, production annulée");
                        break;
                }

                for (int i = 0; i < SCUnite.hauteur; i++)
                {
                    for (int j = 0; j < SCUnite.largeur; j++)
                    {
                        SCUnite.list_case[i, j] = Niveau.grille[(int)(i + unite.transform.position.x - 0.5), (int)(j + unite.transform.position.y - 0.5)];
                        SCUnite.list_case[i, j].GetComponent<Case>().occupe = true;
                        SCUnite.list_case[i, j].GetComponent<Case>().element = unite;
                    }
                }

                if (SCUnite.camp == "Ours")
                {
                    Niveau.list_element[0].Add(unite);
                }
                else
                {
                    Niveau.list_element[1].Add(unite);
                }
            }
        }

        private Vector2 PlacerUnite(GameObject uniteAPlacer)
        {
            Unite SCUnite = uniteAPlacer.GetComponent<Unite>();
            int numTour = 1;
            bool place = false;

            Vector2 position = new Vector2();

            Vector2 depart = new Vector2(transform.position.x - SCUnite.largeur / 2 - 0.5f,
                                         transform.position.y - SCUnite.hauteur / 2 - 1.5f);

            if(Niveau.grille[(int)depart.x, (int)depart.y].GetComponent<Case>().occupe == false)
            {
                Niveau.grille[(int)depart.x, (int)depart.y].GetComponent<Case>().occupe = true;
                Niveau.grille[(int)depart.x, (int)depart.y].GetComponent<Case>().element = uniteAPlacer;
                position = depart;
            }
            else
            {
                while(place == false && numTour < 1000)
                {
					for (int i = 0; i < hauteur; i++)
					{
						for (int j = 0; j < largeur; j++)
						{
							if(Niveau.grille[((int)(list_case[j, i].transform.position.x + 1)),
							                 ((int)(list_case[j, i].transform.position.y))]
							   .GetComponent<Case>().occupe == false)
							{
								position = new Vector2((int)list_case[j, i].transform.position.x + 1.5f, (int)list_case[j, i].transform.position.y + 0.5f);
								place = true;
							}
							else if(Niveau.grille[(int)(list_case[j, i].transform.position.x - 1),
							                      (int)(list_case[j, i].transform.position.y)]
							        .GetComponent<Case>().occupe == false)
							{
								position = new Vector2((int)list_case[j, i].transform.position.x - 0.5f, (int)list_case[j, i].transform.position.y + 0.5f);
								place = true;
							}
							else if(Niveau.grille[(int)(list_case[j, i].transform.position.x),
							                      (int)(list_case[j, i].transform.position.y + 1)]
							        .GetComponent<Case>().occupe == false)
							{
								position = new Vector2((int)list_case[j, i].transform.position.x + 0.5f, (int)list_case[j, i].transform.position.y + 1.5f);
								place = true;
							}
							else if(Niveau.grille[(int)(list_case[j, i].transform.position.x),
							                      (int)(list_case[j, i].transform.position.y - 1)]
							        .GetComponent<Case>().occupe == false)
							{
								position = new Vector2((int)list_case[j, i].transform.position.x + 0.5f, (int)list_case[j, i].transform.position.y - 0.5f);
								place = true;
							}
						}
					}
                    numTour++;
                }
            }

            return position;
        }
    }
}

